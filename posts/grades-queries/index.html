<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
 
   <link rel="stylesheet" href="/libs/highlight/github.min.css">
 
  <link rel="stylesheet" href="/css/franklin.css">
  <link rel="stylesheet" href="/css/basic.css">
  <link rel="icon" href="/assets/favicon.png">
   <title> Grades queries - Huijzer.xyz </title> 
  

  <meta property="og:title" content="Grades queries" />
  <meta property="og:type" content="article" /> 
  <meta property="og:description" content="Using SQL like query syntax in Julia." />
  <meta property="og:image" content="https://huijzer.xyz/assets/self.jpg" />

  <meta name="twitter:title" content="Grades queries" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:creator" content="@rikhuijzer"/>

  <script src="https://cdn.usefathom.com/script.js" data-site="BQRGKKNX" defer></script>
</head>
<body>
  <header>
<div class="blog-name"><a href="/">HUIJZER.XYZ</a></div>
<nav>
  <ul>
    <li><a href="/about/">About</a></li>
    <li><a href="/posts/">Blog</a></li>
    <li><a type="application/rss+xml" href="https://huijzer.xyz/feed.xml">
      <img class="rss-icon" src="/assets/feed.svg">
      </a></li>
  </ul>
</nav>
</header>


<div class="franklin-content">
   <h1 class="page-title"> Grades queries </h1> 
   <span class="page-date"> 2020-11-26 </span> 
</div>
<div class="franklin-content">
<p><strong>EDIT:</strong> <em>This query syntax is nice but can be very slow for many columns, which is quite annoying when using it in a project. Instead, checkout Tom Kwong&#39;s DataFrames <a href="https://ahsmart.com/pub/data-wrangling-with-data-frames-jl-cheat-sheet/">cheat sheet</a>.</em></p>
<p>Most data in the real-world is relational, that is, there are relationships in the data. For example, a relation could be between a table containing person names and ages and another table containing person names and grades. If both tables are about the same persons, then there is a relationship on name between the tables. On these kinds of data, we want to do <em>queries</em>: a request for information from the data. An interesting request could be &quot;give all the names, ages and grades for all the persons&quot;.</p>
<p>This problem of combining tables should not be solved by simply putting all the data into one big table, since you will get empty cells. According to my former databases professor, <a href="http://wwwis.win.tue.nl/~debra/">Paul De Bra</a>, you should try to avoid empty cells. This makes sense when you imagine what happens if you are going to combine many tables. For example, when combining two tables <code>A</code> and <code>B</code> on name where <code>B</code> is missing the names of 10 persons, then the combination will have empty cells for each missing person multiplied by every column in <code>B</code>. If <code>B</code> contains 3 columns &#40;for example, <code>:weight</code>, <code>:length</code> and <code>:age</code>&#41;, then this basic comination will already contain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>∗</mo><mn>3</mn><mo>=</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">10 * 3 = 30</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span> empty cells. These cells are a waste of storage and are difficult to query.</p>
<p>So, it is important to be able to effectively query multiple tables. In the rest of this post, I show ways to do this in Julia with the help of the Query package.</p>
<div class="franklin-toc"><ol><li><a href="#example_data">Example data</a></li><li><a href="#naive_approach">Naive approach</a></li><li><a href="#join">Join</a></li><li><a href="#debugging_tips">Debugging tips</a></li><li><a href="#grouping">Grouping</a></li><li><a href="#filtering_and_sorting">Filtering and sorting</a></li></ol></div>
<h2 id="example_data"><a href="#example_data" class="header-anchor">Example data</a></h2>
<p>Lets create some relational data for some fictional students who could do an exam in 2019 and 2020.</p>

<pre><code class="language-julia">using DataFrames

person &#61; DataFrame&#40;name&#61;&#91;&quot;Bob&quot;, &quot;Sally&quot;, &quot;Bob 2&quot;, &quot;Alice&quot;, &quot;Hank&quot;&#93;, age&#61;&#91;17, 18, 17, 20, 19&#93;&#41;</code></pre>
<p> <table><tr><th align="right">name</th><th align="right">age</th></tr><tr><td align="right">Bob</td><td align="right">17</td></tr><tr><td align="right">Sally</td><td align="right">18</td></tr><tr><td align="right">Bob 2</td><td align="right">17</td></tr><tr><td align="right">Alice</td><td align="right">20</td></tr><tr><td align="right">Hank</td><td align="right">19</td></tr></table>
</p>
<pre><code class="language-julia">grades_2019 &#61; DataFrame&#40;name&#61;&#91;&quot;Sally&quot;, &quot;Bob&quot;, &quot;Alice&quot;, &quot;Hank&quot;&#93;, grade_2019&#61;&#91;1, 5, 8.5, 4&#93;&#41;</code></pre>
<table><tr><th align="right">name</th><th align="right">grade_2019</th></tr><tr><td align="right">Sally</td><td align="right">1.0</td></tr><tr><td align="right">Bob</td><td align="right">5.0</td></tr><tr><td align="right">Alice</td><td align="right">8.5</td></tr><tr><td align="right">Hank</td><td align="right">4.0</td></tr></table>

<pre><code class="language-julia">grades_2020 &#61; DataFrame&#40;name&#61;&#91;&quot;Bob 2&quot;, &quot;Sally&quot;, &quot;Hank&quot;&#93;, grade_2020&#61;&#91;9.5, 9.5, 5&#93;&#41;</code></pre>
<table><tr><th align="right">name</th><th align="right">grade_2020</th></tr><tr><td align="right">Bob 2</td><td align="right">9.5</td></tr><tr><td align="right">Sally</td><td align="right">9.5</td></tr><tr><td align="right">Hank</td><td align="right">5.0</td></tr></table>

<h2 id="naive_approach"><a href="#naive_approach" class="header-anchor">Naive approach</a></h2>
<p>Say, we would like to obtain a table combining the names and ages with the grades of 2019. A naive approach would be to write</p>
<pre><code class="language-julia">function combine&#40;row&#41;
  name &#61; row.name
  age &#61; row.age
  matches &#61; filter&#40;x -&gt; x.name &#61;&#61; name, grades_2019&#41;
  grade_2019 &#61; nrow&#40;matches&#41; &#33;&#61; 0 ? first&#40;matches&#41;.grade_2019 : missing
  DataFrame&#40;name &#61; name, age &#61; age, grade_2019 &#61; grade_2019&#41;
end
rows &#61; combine.&#40;eachrow&#40;person&#41;&#41;
vcat&#40;rows...&#41;</code></pre>
<table><tr><th align="right">name</th><th align="right">age</th><th align="right">grade_2019</th></tr><tr><td align="right">Bob</td><td align="right">17</td><td align="right">5.0</td></tr><tr><td align="right">Sally</td><td align="right">18</td><td align="right">1.0</td></tr><tr><td align="right">Bob 2</td><td align="right">17</td><td align="right"></td></tr><tr><td align="right">Alice</td><td align="right">20</td><td align="right">8.5</td></tr><tr><td align="right">Hank</td><td align="right">19</td><td align="right">4.0</td></tr></table>

<p>Now imagine having to combine multiple tables. The code will quickly become tedious.</p>
<h2 id="join"><a href="#join" class="header-anchor">Join</a></h2>
<p>Instead, we can obtain the same output by using <a href="https://github.com/queryverse/Query.jl">Query.jl</a>. The Query package has two styles. One style is very similar to <a href="https://dplyr.tidyverse.org/">dplyr</a> from Tidyverse. The other style is Language Integrated Query &#40;LINQ&#41; style &#40;documentation <a href="https://www.queryverse.org/Query.jl/stable/linqquerycommands/">here</a>&#41;. LINQ style is the style I&#39;m using, since I find it the most intuitive of the two. So, to obtain the previous table again, we can write</p>
<pre><code class="language-julia">using Query

@from i in person begin
  @left_outer_join j in grades_2019 on i.name equals j.name
  @select &#123;i.name, i.age, j.grade_2019&#125;
  @collect DataFrame
end</code></pre>
<table><tr><th align="right">name</th><th align="right">age</th><th align="right">grade_2019</th></tr><tr><td align="right">Bob</td><td align="right">17</td><td align="right">5.0</td></tr><tr><td align="right">Sally</td><td align="right">18</td><td align="right">1.0</td></tr><tr><td align="right">Bob 2</td><td align="right">17</td><td align="right"></td></tr><tr><td align="right">Alice</td><td align="right">20</td><td align="right">8.5</td></tr><tr><td align="right">Hank</td><td align="right">19</td><td align="right">4.0</td></tr></table>

<p>Here, the <code>@left_outer_join</code> ensures that all the persons in <code>person</code> have one row in the final output.  A normal <code>@join</code> would omit the row for Bob 2, because Bob 2 is not in the <code>grades_2019</code> table.</p>
<pre><code class="language-julia">@from i in person begin
  @join j in grades_2019 on i.name equals j.name
  @select &#123;i.name, i.age, j.grade_2019&#125;
  @collect DataFrame
end</code></pre>
<table><tr><th align="right">name</th><th align="right">age</th><th align="right">grade_2019</th></tr><tr><td align="right">Bob</td><td align="right">17</td><td align="right">5.0</td></tr><tr><td align="right">Sally</td><td align="right">18</td><td align="right">1.0</td></tr><tr><td align="right">Alice</td><td align="right">20</td><td align="right">8.5</td></tr><tr><td align="right">Hank</td><td align="right">19</td><td align="right">4.0</td></tr></table>

<p>The joins can be combined to see who did the exam twice and by how much the grade is increased on the second try.</p>
<pre><code class="language-julia">@from i in person begin
  @left_outer_join j in grades_2019 on i.name equals j.name
  @left_outer_join k in grades_2020 on i.name equals k.name
  @select &#123;i.name, j.grade_2019, k.grade_2020, 
    increase&#61;k.grade_2020 - j.grade_2019&#125;
  @collect DataFrame
end</code></pre>
<table><tr><th align="right">name</th><th align="right">grade_2019</th><th align="right">grade_2020</th><th align="right">increase</th></tr><tr><td align="right">Bob</td><td align="right">5.0</td><td align="right"></td><td align="right"></td></tr><tr><td align="right">Sally</td><td align="right">1.0</td><td align="right">9.5</td><td align="right">8.5</td></tr><tr><td align="right">Bob 2</td><td align="right"></td><td align="right">9.5</td><td align="right"></td></tr><tr><td align="right">Alice</td><td align="right">8.5</td><td align="right"></td><td align="right"></td></tr><tr><td align="right">Hank</td><td align="right">4.0</td><td align="right">5.0</td><td align="right">1.0</td></tr></table>

<p>or who passed the course</p>
<pre><code class="language-julia">@from i in person begin
	@left_outer_join j in grades_2019 on i.name equals j.name
	@left_outer_join k in grades_2020 on i.name equals k.name		
	@select &#123;i.name, passed&#61;j.grade_2019 &gt; 6 || k.grade_2020 &gt; 6&#125;
  @collect DataFrame
end</code></pre>
<table><tr><th align="right">name</th><th align="right">passed</th></tr><tr><td align="right">Bob</td><td align="right">false</td></tr><tr><td align="right">Sally</td><td align="right">true</td></tr><tr><td align="right">Bob 2</td><td align="right">true</td></tr><tr><td align="right">Alice</td><td align="right">true</td></tr><tr><td align="right">Hank</td><td align="right">false</td></tr></table>

<h2 id="debugging_tips"><a href="#debugging_tips" class="header-anchor">Debugging tips</a></h2>
<p>Before going to more difficult examples, it is helpful to look what is happening inside the join. Printing all the rows can aid in solving errors.</p>
<pre><code class="language-julia">@from i in person begin
  @join j in grades_2019 on i.name equals j.name
  @select &#123;i, j&#125;
  @collect DataFrame
end</code></pre>
<table><tr><th align="right">i</th><th align="right">j</th></tr><tr><td align="right">&#40;name &#61; &quot;Bob&quot;, age &#61; 17&#41;</td><td align="right">&#40;name &#61; &quot;Bob&quot;, grade_2019 &#61; 5.0&#41;</td></tr><tr><td align="right">&#40;name &#61; &quot;Sally&quot;, age &#61; 18&#41;</td><td align="right">&#40;name &#61; &quot;Sally&quot;, grade_2019 &#61; 1.0&#41;</td></tr><tr><td align="right">&#40;name &#61; &quot;Alice&quot;, age &#61; 20&#41;</td><td align="right">&#40;name &#61; &quot;Alice&quot;, grade_2019 &#61; 8.5&#41;</td></tr><tr><td align="right">&#40;name &#61; &quot;Hank&quot;, age &#61; 19&#41;</td><td align="right">&#40;name &#61; &quot;Hank&quot;, grade_2019 &#61; 4.0&#41;</td></tr></table>

<p>So, basically the join puts the two tables next to each other and inside the select we just get the name if we type <code>i.name</code>.  Also note that the result of <code>i.name</code> would be the same as <code>j.name</code>, as expected.</p>
<h2 id="grouping"><a href="#grouping" class="header-anchor">Grouping</a></h2>
<p>Like in most real-world datasets, this dataset contains a mistake. Bob complained that he had, in fact, passed the course. His second grade is listed for the name Bob 2. This, in LINQ, is called grouping.  Basically, grouping can <em>group</em> multiple rows into one. This example is, unfortunately, quite involved, but I was unable to come up with a simpler example for which the output makes sense too.</p>
<p>Lets first add a row to add a &quot;real&quot; name for every row so that these real names can be grouped. Here, the <code>let</code> command is just a nice way to move the definition of <code>real_name</code>, <code>all_grades</code> and <code>pass</code> out of the <code>select</code>.  The <code>into</code> command is required by <code>group</code> to clarify that we move on to a new variable. Without <code>into</code>, multiple variables, such as <code>i</code> and <code>j</code>, can be accessed on the same line. However, grouping throws some table rows away. This means that variables from before the <code>group</code> aren&#39;t pointing to the same row as the variables after <code>group</code>.  In the <code>select</code>, I have used <code>into s</code> to make <code>s.real_name</code> available to the <code>group</code> command.</p>
<pre><code class="language-julia">results &#61; @from i in person begin
  @left_outer_join j in grades_2019 on i.name equals j.name
  @left_outer_join k in grades_2020 on i.name equals k.name
  @let real_name &#61; &#40;k.name &#61;&#61; &quot;Bob 2&quot;&#41; ? &quot;Bob&quot; : j.name
  @select &#123;i.name, j.grade_2019, k.grade_2020, real_name&#125; into s
  @group s by s.real_name into g
  @let all_grades &#61; &#91;g.grade_2019...; g.grade_2020...&#93;
  @let pass &#61; any&#40;&#91;grade &gt; 6 for grade in all_grades&#93;&#41;
  @select &#123;name &#61; first&#40;g.name&#41;, pass&#125;
  @collect DataFrame
end</code></pre>
<p> <table><tr><th align="right">name</th><th align="right">pass</th></tr><tr><td align="right">Bob</td><td align="right">true</td></tr><tr><td align="right">Sally</td><td align="right">true</td></tr><tr><td align="right">Alice</td><td align="right">true</td></tr><tr><td align="right">Hank</td><td align="right">false</td></tr></table>
</p>
<h2 id="filtering_and_sorting"><a href="#filtering_and_sorting" class="header-anchor">Filtering and sorting</a></h2>
<p>Of course, the most interesting part of this example is to obtain all the names for the people who passed the course and it would be nice to have this in alphabetical order. Specifically, we want to filter such that we obtain only the people <em>where</em> <code>pass &#61;&#61; true</code>.</p>
<pre><code class="language-julia">@from i in results begin
  @where i.pass &#61;&#61; true
  @orderby ascending&#40;i.name&#41;
  @select &#123;i.name&#125;
  @collect DataFrame
end</code></pre>
<p> <table><tr><th align="right">name</th></tr><tr><td align="right">Alice</td></tr><tr><td align="right">Bob</td></tr><tr><td align="right">Sally</td></tr></table>
</p>
<div class="page-foot">
  <div class="copyright">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Rik Huijzer. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
    Last update: 2021-09-23.
  </div>
</div>
</div><!-- CONTENT ENDS HERE -->
    
        



    
    
        <script src="/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
